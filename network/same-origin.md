# Same-Origin PolicyIn computing, the **same-origin policy** (sometimes abbreviated as SOP) is an important concept in the web application security model. Under the policy, a web browser permits scripts contained in a first web page to access data in a second web page, but only if both web pages have the same origin. An origin is defined as a combination of **URI scheme**, **host name**, and **port number**. This policy prevents a malicious script on one page from obtaining access to sensitive data on another web page through that page's Document Object Model.This mechanism bears a particular significance for modern web applications that extensively depend on HTTP cookies to maintain authenticated user sessions, as servers act based on the HTTP cookie information to reveal sensitive information or take state-changing actions. A strict separation between content provided by unrelated sites must be maintained on the client-side to prevent the loss of data confidentiality or integrity.It is very important to remember that the same-origin policy applies only to scripts. This means that resources such as images, CSS, and dynamically-loaded scripts can be accessed across origins via the corresponding HTML tags (with fonts being a notable exception). Attacks take advantage of the fact that the same origin policy does not apply to HTML tags.The following table gives examples of origin comparisons with the URL *http://store.company.com/dir/page.html*:|URL                                                    | Outcome     | Reason               ||:------                                                |:------      |:------               ||http://store.company.com/dir2/other.html               |Same origin  |Only the path differs ||http://store.company.com/dir/inner/another.html        |Same origin  |Only the path differs ||**https**://store.company.com/page.html                |Failure      |Different protocol    ||http://store.company.com:**81**/dir/page.html          |Failure      |Different port        ||http://**news**.company.com/dir/page.html              |Failure      |Different host        |# Relaxing the same-origin policy### Cross-Origin Resource SharingThe other technique for relaxing the same-origin policy is standardized under the name Cross-Origin Resource Sharing. This standard extends HTTP with a new Origin request header and a new Access-Control-Allow-Origin response header. It allows servers to use a header to explicitly list origins that may request a file or to use a wildcard and allow a file to be requested by any site. Browsers such as Firefox 3.5, Safari 4 and Internet Explorer 10 use this header to allow the cross-origin HTTP requests with XMLHttpRequest that would otherwise have been forbidden by the same-origin policy.### Cross-document messagingAnother technique, cross-document messaging allows a script from one page to pass textual messages to a script on another page regardless of the script origins. Calling the **postMessage()** method on a Window object asynchronously fires an "onmessage" event in that window, triggering any user-defined event handlers. A script in one page still cannot directly access methods or variables in the other page, but they can communicate safely through this message-passing technique.### JSONPSince HTML \<script\> elements are allowed to retrieve and execute content from other domains, a page can bypass the same-origin policy and receive JSON data from a different domain by loading a resource that returns a JSONP payload. JSONP payloads consist of an internal JSON payload wrapped by a pre-defined function call. When the script resource is loaded by the browser, the designated callback function will be invoked to process the wrapped JSON payload.### document.domain PropertyIf two windows (or frames) contain scripts that set domain to the same value, the same-origin policy is relaxed for these two windows, and each window can interact with the other. For example, cooperating scripts in documents loaded from orders.example.com and catalog.example.com might set their document.domain properties to “example.com”, thereby making the documents appear to have the same origin and enabling each document to read properties of the other. Setting this property implicitly sets the port to null, which most browsers will interpret differently from port 80 or even an unspecified port. To assure that access will be allowed by the browser, set the document.domain property of both pages.### Proxy如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx出场了。Nginx配置:~~~server{    # 监听9099端口    listen 9099;    # 域名是localhost    server_name localhost;    #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871     location ^~ /api {        proxy_pass http://localhost:9871;}~~~    # References 1. [不要再问我跨域的问题了](https://segmentfault.com/a/1190000015597029)2. [Same-origin policy](https://en.wikipedia.org/wiki/Same-origin_policy)3. [Same-origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)4. [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)